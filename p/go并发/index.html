<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='go内存模型、channel、并发包相关类的实现原理'><title>go并发</title>

<link rel='canonical' href='http://nixum.cc/p/go%E5%B9%B6%E5%8F%91/'>

<link rel="stylesheet" href="/scss/style.min.92530ae6146419b2553c7da1866a1ac352d4c1a4d2f985110524bd60c6094d8c.css"><meta property='og:title' content='go并发'>
<meta property='og:description' content='go内存模型、channel、并发包相关类的实现原理'>
<meta property='og:url' content='http://nixum.cc/p/go%E5%B9%B6%E5%8F%91/'>
<meta property='og:site_name' content='Nixum Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='go并发' /><meta property='article:tag' content='go内存模型' /><meta property='article:tag' content='go channel原理' /><meta property='article:published_time' content='2021-03-22T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-05-15T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="go并发">
<meta name="twitter:description" content="go内存模型、channel、并发包相关类的实现原理">
    <link rel="shortcut icon" href="img/favicon.ico" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>









        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/go/" >
                go
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/go%E5%B9%B6%E5%8F%91/">go并发</a>
    </h2>

    
    <h3 class="article-subtitle">
        go内存模型、channel、并发包相关类的实现原理
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Mar 22, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    6 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p>[TOC]</p>
<h1 id="内存模型">内存模型</h1>
<p>这里的内存模型不是指内存分配、整理回收的规范，而是在并发环境下多goroutine读取共享变量时变量的可见性条件。</p>
<p>由于不同的架构和不同的编译器优化，会发生指令重排，导致程序运行时不一定会按照代码的顺序执行，因此两个goroutine在处理共享变量时，能够看到其他goroutine对这个变量进行的写结果。</p>
<p>happens-before：程序的执行顺序和代码的顺序一样，就算真的发生了重排，从行为上也能保证和代码的指定顺序一样。</p>
<p>Go不像Java有volatile关键字实现CPU屏障来保证指令不重排，而是使用不同架构的内存屏障指令来实现同一的并发原语。</p>
<p><strong>Go只保证goroutine内部重排对读写顺序没有影响</strong>，如果存在共享变量的访问，则影响另一个goroutine。因此当有多个goroutine对共享变量的操作时，需要保证对该共享变量操作的happens-before顺序。</p>
<h2 id="证heppen-before的手段">证heppen before的手段</h2>
<ul>
<li>
<p>init函数：同一个包下可以有多个init函数，多个签名相同的init函数；main函数一定在导入的包的init函数执行之后执行；当有多个init函数时，从main文件出发，递归找到对应的包 - 包内文件名顺序 - 一个文件内init函数顺序执行init函数。</p>
</li>
<li>
<p>全局变量：包级别的变量在同一个文件中是按照声明顺序逐个初始化的；当该变量在初始化时依赖其它的变量时，则会先初始化该依赖的变量。同一个包下的多个文件，会按照文件名的排列顺序进行初始化。</p>
<p>init函数也是如此，当init函数引用了全局变量a，运行main函数时，肯定是先初始化a，再执行init函数。</p>
<p>当init函数和全局变量无引用关系时，先初始化全局变量，再执行init函数</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">b</span>  <span class="c1">// == 9
</span><span class="c1"></span>  <span class="nx">b</span> <span class="p">=</span> <span class="nf">f</span><span class="p">()</span>    <span class="c1">// == 4
</span><span class="c1"></span>  <span class="nx">c</span> <span class="p">=</span> <span class="nf">f</span><span class="p">()</span>    <span class="c1">// == 5
</span><span class="c1"></span>  <span class="nx">d</span> <span class="p">=</span> <span class="mi">3</span>      <span class="c1">// 全部初始化完成后 == 5 
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">d</span><span class="o">++</span>
  <span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
<span class="o">---</span>
<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="nf">getA</span><span class="p">()</span>

<span class="kd">func</span> <span class="nf">getA</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">return</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="c1">// 运行后，输出2，3，4
</span><span class="c1"></span><span class="o">---</span>
<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="nf">getA</span><span class="p">()</span>

<span class="kd">func</span> <span class="nf">getA</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">return</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="c1">// 运行后，输出2，4
</span></code></pre></div><ul>
<li>goroutine：启动goroutine的go语句执行，一定happens before此goroutine内的代码</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">print</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
	<span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>
<span class="nx">执行hello方法</span><span class="err">，</span><span class="nx">必定打印出hello</span>
</code></pre></div><ul>
<li>channel：
<ul>
<li>send操作必定heppen before于receive操作；</li>
<li>close一个channel的操作，必定happen before从关闭的channel中读取一个零值；</li>
</ul>
</li>
<li>此外还有Mutex / RWMutex、WaitGroup、Once、atomic</li>
</ul>
<h1 id="channel">Channel</h1>
<p>Channel的设计基于CSP模型。</p>
<p>CSP模型（Communicating Sequential Process，通信顺序进程），允许使用进程组来描述系统，独立运行，并且只通过消息传递的方式通信。</p>
<p>本质上就是，在使用协程执行函数时，不通过内存共享(会用到锁)的方式通信，而是通过Channel通信传递数据。</p>
<h2 id="数据结构">数据结构</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">qcount</span>   <span class="kt">uint</span>   <span class="c1">// 已经接收但还没被取走的元素个数，即channel中的循环数组的元素个数
</span><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>   <span class="c1">// channel中的循环数组的长度
</span><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// channel中缓冲区数据指针，buf是一个循环数组，buf的总大小是elemsize的整数倍
</span><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span> <span class="c1">// 当前channel能够收发的元素大小
</span><span class="c1"></span>	<span class="nx">closed</span>   <span class="kt">uint32</span>
	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// 当前channel能够收发的元素类型
</span><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>   <span class="c1">// 指向底层循环数组buf，表示当前可发送的元素位置的索引值，当sendx=dataqsiz时，会回到buf数组的起点，一旦接收新数据，指针就会加上elemsize，移向下个位置
</span><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>   <span class="c1">// 指向底层循环数组buf，表示当前可接收的元素位置的索引值
</span><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>  <span class="c1">// 等待队列，存储当前channel因缓冲区空间不足而接收阻塞的goroutine列表，双向链表
</span><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>  <span class="c1">// 等待队列，存储当前channel因缓冲区空间不足而发送阻塞的goroutine列表，双向链表
</span><span class="c1"></span>
	<span class="nx">lock</span> <span class="nx">mutex</span>  <span class="c1">// 互斥锁，保证每个读channel或写channel的操作都是原子的
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">waitq</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">sudog</span>
	<span class="nx">last</span>  <span class="o">*</span><span class="nx">sudog</span>
<span class="p">}</span>
</code></pre></div><h2 id="基本">基本</h2>
<ul>
<li>
<p>chan是引用类型，使用make关键字创建，未初始化时的零值是nil，如</p>
<p><code>ch := make(chan, string, 10)</code>，创建一个能处理string的缓冲区大小为10的channel，效果相当于异步队列，除非缓冲区用完，否则不会阻塞；</p>
<p><code>ch := make(chan, string)</code>，则创建了一个不存在缓冲区的channel，效果相当于同步阻塞队列，即如果连续发送两次数据，第一次如果没有被接收的话，第二次就会被阻塞。</p>
</li>
<li>
<p>channel作为通道，负责在多个goroutine间传递数据，解决多线程下共享数据竞争问题。</p>
</li>
<li>
<p>当 chan是 nil时，对chan的发送和接收的调用者总是阻塞的</p>
</li>
<li>
<p>带有 &lt;- 的chan是有方向的，不带 &lt;- 的chan是双向的，比如</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">  <span class="kd">chan</span> <span class="kt">string</span>        <span class="c1">// 双向chan，可以发送和接收string
</span><span class="c1"></span>  <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}</span>    <span class="c1">// 只能发送struct到chan中
</span><span class="c1"></span>  <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span>         <span class="c1">// 只能从chan中接收int
</span></code></pre></div><ul>
<li>chan可以是任何类型的，比如可以是 chan&lt;- 类型，&lt;-总是尽量和左边的chan结合，比如</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kt">int</span>    <span class="c1">// 等价于 chan&lt;- (chan int)
</span><span class="c1"></span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span>  <span class="c1">// 等价于 chan&lt;- (&lt;-chan int)
</span><span class="c1"></span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span>  <span class="c1">// 等价于 &lt;-chan (&lt;-chan int)
</span><span class="c1"></span><span class="kd">chan</span> <span class="p">(</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>  <span class="c1">// 等价于 chan (&lt;-chan int)
</span></code></pre></div><ul>
<li>接收数据时可以有两个返回值，第一个是返回的元素，第二个是bool类型，表示是否成功地从chan中读取到一个值。如果是false，说明chan以及被close并且chan中没有缓存的数据，此时第一个元素是零值。所以，如果接收时第一个元素是零值，可能是sender真的发送了零值，也可能是closed并且没有元素导致的。</li>
<li>双向chan可以赋值给单向chan，但反过来不可以</li>
</ul>
<h2 id="初始化">初始化</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">elem</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span>
        <span class="c1">// 略去检查代码
</span><span class="c1"></span>        <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
    <span class="o">...</span>

    <span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1">// chan的size或者元素的size是0，不必创建buf
</span><span class="c1"></span>      <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>
    <span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1">// 元素不是指针，分配一块连续的内存给hchan数据结构和buf
</span><span class="c1"></span>      <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
            <span class="c1">// hchan数据结构后面紧接着就是buf
</span><span class="c1"></span>      <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
      <span class="c1">// 元素包含指针，那么单独分配buf
</span><span class="c1"></span>      <span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>
  
    <span class="c1">// 元素大小、类型、容量都记录下来
</span><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankHchan</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">c</span>
  <span class="p">}</span>
</code></pre></div><h2 id="发送数据">发送数据</h2>
<p>使用<code>ch &lt;- &quot;test&quot;</code>发送数据，最终会调用chansend函数发送数据，该函数设置了阻塞参数为true。</p>
<ol>
<li>如果chan是nil，则把发送者的goroutine park（阻塞休眠），此时发送者将被永久阻塞。</li>
<li>如果chan没有被close，但是chan满了，则直接返回false，但是由于阻塞参数为true，这部分不会被执行。</li>
<li>如果chan被close了，再往里发数据会触发panic。</li>
<li>当存在等待的接收者时，通过send函数，从接收队列recvq中取出最先进入等待的goroutine，直接发送数据，不需要先放到buf中。</li>
<li>当没有接收者，且缓冲区存在空余空间时，会使用chanbuf计算出下一个可以存储数据的位置，将要发送的数据拷贝到缓冲区并增加sendx索引和qcount计数器，将发送的数据写入channel缓冲区，写入后就返回成功。</li>
<li>当不存在缓冲区或者缓冲区已满，会先调用getg函数获取正在发送者的goroutine，执行acquireSudog函数创建sudog对象，设置此次阻塞发送的相关信息（如发送的channel、是否在select控制结构中和待发送数据的内存地址、发送数据的goroutine），将该sudog对象加入sendq队列，调用goparkunlock函数让当前发送者的goroutine进入等待，表示当前goroutine正在等待其他goroutine从channel中接收数据，等待调度器唤醒。调度器唤醒后，将一些属性值设置为零，并释放sudog对象，表示向channel发送数据结束。</li>
</ol>
<h2 id="接收数据">接收数据</h2>
<p>使用<code> str &lt;- ch 或 str, ok &lt;- ch ok用于判断ch是否关闭，如果没有ok，可能会无法分配str接收到的零值是发送者发的还是ch关闭</code>接收数据，会转化为调用chanrecv1和chanrecv2函数，但最终会调用chanrecv函数接收数据。chanrecv1和chanrecv2函数都是设置阻塞参数为true。</p>
<ol>
<li>
<p>如果chan是nil，则把接收者的goroutine park（阻塞休眠），接收者被永久阻塞。</p>
</li>
<li>
<p>如果当前channel已经被关闭且缓冲区不存在任何数据，此时会清除ep指针中的数据并立即返回。</p>
</li>
<li>
<p>如果chan已经被close，且队列中没有缓存元素，返回selected为true，received为false。</p>
</li>
<li>
<p>当channel的sendq队列存在等待状态的goroutine时，如果是unbuffer的chan，直接使用recv函数直接从阻塞的发送者中获取数据；如果是有buffer的chan，则从sendq队列的头中读取一个值，并把这个发送者的值加入队列的尾部，即优先获取发送者的数据。</p>
</li>
<li>
<p>当channel的sendq队列没有等待状态的goroutine，且缓冲区存在数据时，从channel的缓冲区中的recvx的索引位置接收数据，如果接收数据的内存地址不为空，会直接将缓冲区里的数据拷贝到内存中，清除队列中的数据，递增recvx，递减qcount，完成数据接收。当发送recvx超过channel的buf时，会将其归零。</p>
<p>这个和chansend共用一把锁，所以不会有并发问题。</p>
</li>
<li>
<p>当channel的sendq队列没有等待状态的goroutine，且缓冲区不存在数据时，创建sudog对象，加入recvq队列，当前goroutine进入阻塞状态，等待其他goroutine向channel发送数据。</p>
</li>
</ol>
<h2 id="关闭">关闭</h2>
<ol>
<li>如果 chan 为 nil，close 会 panic</li>
<li>如果 chan 已经 closed，再次 close 也会 panic。</li>
<li>否则的话，如果 chan 不为 nil，chan 也没有 closed，就把等待队列中的 sender（writer）和 receiver（reader）从队列中全部移除并唤醒。</li>
</ol>
<h2 id="应用场景">应用场景</h2>
<ul>
<li>实现生产者 - 消费组模型，数据传递，比如<a class="link" href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/"  target="_blank" rel="noopener"
    >worker池的实现</a></li>
<li>信号通知：利用 如果chan为空，那receiver接收数据的时候就会阻塞等待，直到chan被关闭或有新数据进来 的特点，将一个协程将信号(closing、closed、data ready等)传递给另一个或者另一组协程，比如 wait/notify的模式。</li>
<li>任务编排：让一组协程按照一定的顺序并发或串行执行，比如实现waitGroup的功能</li>
<li>实现互斥锁的机制，比如，容量为 1 的chan，放入chan的元素代表锁，谁先取得这个元素，就代表谁先获取了锁</li>
</ul>
<blockquote>
<p>共享资源的并发访问使用传统并发原语；</p>
<p>复杂的任务编排和消息传递使用 Channel；</p>
<p>消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond；</p>
<p>简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；</p>
<p>需要和 Select 语句结合，使用 Channel；需要和超时配合时，使用 Channel 和 Context。</p>
</blockquote>
<p>注意点：使用chan要注意panic和goroutine泄露，另外，只要一个 chan 还有未读的数据，即使把它 close 掉，你还是可以继续把这些未读的数据消费完，之后才是读取零值数据。</p>
<p>在使用chan和select配合时要注意会出现goroutine泄漏的情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">process</span><span class="p">(</span><span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 模拟处理耗时的业务
</span><span class="c1"></span>        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">((</span><span class="nx">timeout</span> <span class="o">+</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">))</span>
        <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kc">true</span> <span class="c1">// block
</span><span class="c1"></span>        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exit goroutine&#34;</span><span class="p">)</span>
    <span class="p">}()</span>
    <span class="c1">// 如果上面的协程任务处理的时间过长，触发下面select的超时机制，此时process函数返回，之后当上面的协程任务执行完之后，由于process已经执行完，下面result接收chan的值被回收，导致没有接收者，导致上面的协程任务一直卡在 ch &lt;- true，进而导致goroutine泄漏。解决方案就是使用容量为1的ch即可。
</span><span class="c1"></span>    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">result</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">result</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">timeout</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><table>
<thead>
<tr>
<th></th>
<th>nil</th>
<th>empty</th>
<th>full</th>
<th>not full &amp; empty</th>
<th>closed</th>
</tr>
</thead>
<tbody>
<tr>
<td>receive</td>
<td>block</td>
<td>block</td>
<td>read value</td>
<td>read value</td>
<td>返回未读的元素，读完后返回零值</td>
</tr>
<tr>
<td>send</td>
<td>block</td>
<td>write value</td>
<td>block</td>
<td>writed value</td>
<td>panic</td>
</tr>
<tr>
<td>close</td>
<td>panic</td>
<td>closed，没有未读元素</td>
<td>closed，保留未读元素</td>
<td>closed，保留未读元素</td>
<td>panic</td>
</tr>
</tbody>
</table>
<h1 id="并发包">并发包</h1>
<h2 id="mutex---互斥锁">Mutex - 互斥锁</h2>
<h3 id="数据结构-1">数据结构</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">state</span> <span class="kt">int32</span>   <span class="c1">// 分成三部分，最小一位表示锁是否被持有，第二位表示是否有唤醒的goroutine，第三位表示是否处于饥饿状态，剩余的位数表示等待锁的goroutine的数量，最大数量为2^(32-3)-1个，以goroutine初始空间为2k，则达到最大数量时需要消耗1TB内存
</span><span class="c1"></span>	<span class="nx">sema</span>  <span class="kt">uint32</span>  <span class="c1">// 信号量变量，用来控制等待goroutine的阻塞休眠和唤醒
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">mutexLocked</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// 持有锁的标记
</span><span class="c1"></span>	<span class="nx">mutexWoken</span>  <span class="c1">// 唤醒标记
</span><span class="c1"></span>	<span class="nx">mutexStarving</span> <span class="c1">// 饥饿标记
</span><span class="c1"></span>	<span class="nx">mutexWaiterShift</span> <span class="p">=</span> <span class="kc">iota</span>  <span class="c1">// 阻塞等待的waiter数量
</span><span class="c1"></span>    <span class="nx">starvationThresholdNs</span> <span class="p">=</span> <span class="mf">1e6</span>
<span class="p">}</span>
</code></pre></div><h3 id="基本-1">基本</h3>
<ul>
<li>
<p>只有Lock和Unlock两个方法，用于锁定临界区</p>
</li>
<li>
<p>Mutex的零值是没有goroutine等待的未加锁状态，不会因为没有初始化而出现空指针或者无法获取到锁的情况，so无需额外的初始化，直接声明变量即可使用<code>var lock sync.Mutex</code>，或者是在结构体里的属性，均无需初始化</p>
</li>
<li>
<p>如果Mutex已被一个goroutine获取了锁，其他等待的goroutine们会一直等待，组成等待的队列，当该goroutine释放锁后，等待的goroutine是以先进先出的队列排队获取锁；如果此时有新的goroutine也在获取锁，会参与到获取锁的竞争中，如果等待队列中的goroutine等待超过1ms，则会加入队头优先获取锁，新来的goroutine加入到队尾，以此解决等待的goroutine的饥饿问题。</p>
</li>
<li>
<p>Unlock方法可以被任意goroutine调用，释放锁，即使它本身没有持有这个锁，so写的时候要牢记，谁申请锁，就该谁释放锁，保证在一个方法内被调用</p>
</li>
<li>
<p>必须先使用Lock方法才能使用Unlock方法，否则会panic，重复释放锁也会panic</p>
</li>
<li>
<p>自旋的次数与自旋次数、cpu核数，p的数量有关</p>
</li>
<li>
<p>注意Mutex在使用时不能被复制，比如方法传参的没有使用指针，导致执行方法的参数时被复制</p>
</li>
<li>
<p>Mutex是不可重入锁，获取锁的goroutine无法重复获取锁，因为Mutex本身不记录哪个goroutine拥有这把锁，因此如果要实现可重入锁，则需要对Mutex进行包装，实现Locker接口，同时记录获取锁的goroutine的id和重入次数</p>
<p>获取goroutine id的方法：</p>
<p>​	1.使用runtime.Stack()方法获取栈帧里的goroutine id</p>
<p>​	2.获取运行时的g指针，反解出g的TLS结构，获取存在TLS结构中的goroutine id</p>
<p>​	3.给获取锁的goroutine设置token，进行标记</p>
</li>
</ul>
<h3 id="lock方法">Lock方法</h3>
<ol>
<li>调用Lock的goroutine通过CAS的方式获取锁，如果获取到了直接返回，否则进入lockSlow方法</li>
<li>在lockSlow方法内，意味着锁已经被持有，当前调用Lock方法的goroutine正在等待，且非饥饿状态，其首先会自旋，尝试获取锁，而无需休眠，主要是在当临界区耗时很短的场景下提高性能</li>
<li>非饥饿状态下抢锁，先在state锁标志位+1，如果锁已经被持有或者此时是饥饿状态，state的waiter的数量+1，进入等待</li>
<li>如果此时是饥饿状态，并且锁还被持有，state设置为饥饿状态，清除mutexWoken标记，表示非唤醒状态</li>
<li>使用3中的锁位，CAS尝试加锁，如果成功，检查原来的锁是未加锁状态，并且也不是饥饿状态，则成功获取锁，返回</li>
<li>如果是未加锁状态，判断是否是第一次加入waiter队列（通过waitStartTime变量），如果是，则加入队尾，如果不是首次，则加入到队首(设置sema的值)，阻塞等待，直至被唤醒（因为锁被释放了）</li>
<li>唤醒后，如果是饥饿状态（即当前时间 - waitStartTime &gt; 1ms），在state锁标志位+1，waiter数-1，获取锁，然后判断没有其他waiter或者此goroutine等待时间没有超过1ms，清除饥饿标记</li>
</ol>
<h3 id="unlock方法">Unlock方法</h3>
<ol>
<li>将state的锁位-1，如果state=0，即此时没有加锁，且没有正在等待获取锁的goroutine，则直接结束方法，如果state != 0，执行unlockSlow方法</li>
<li>如果Mutex处于饥饿状态，直接唤醒等待队列中的waiter</li>
<li>如果Mutex处于正常状态，如果没有waiter，或者已经有在处理的情况，则直接释放锁，state锁位-1，返回；否则，waiter数-1，设置唤醒标记，通过CAS解锁，唤醒在等待锁的goroutine（此时新老goroutine一起竞争锁）</li>
</ol>
<h3 id="基于mutex的拓展">基于Mutex的拓展</h3>
<ul>
<li>可重入锁</li>
<li>增加tryLock方法，通过返回true或false来表示获取锁成功或失败，主要用于控制获取锁失败后的行为，而不用阻塞在方法调用上</li>
<li>增加等待计数器，比如等待多少时间后还没获取到锁则放弃</li>
<li>增加可观测性指标，比如等待锁的goroutine的数量，需要使用unsafe.Pointer方法获取Mutex中的state的值，解析出正在等待的goroutine的数量</li>
<li>实现线程安全的队列，通过在出队和入队方法中使用Mutex保证线程安全</li>
</ul>
<h2 id="rwmutex---读写锁">RWMutex - 读写锁</h2>
<h3 id="数据结构-2">数据结构</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RWMutex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">w</span> <span class="nx">Mutex</span>           <span class="c1">// 互斥锁解决多个writer的竞争
</span><span class="c1"></span>    <span class="nx">writerSem</span> <span class="kt">uint32</span>  <span class="c1">// writer信号量 
</span><span class="c1"></span>    <span class="nx">readerSem</span> <span class="kt">uint32</span>  <span class="c1">// reader信号量 
</span><span class="c1"></span>    <span class="nx">readerCount</span> <span class="kt">int32</span> <span class="c1">// reader的数量，可以是负数，负数表示此时有writer等待请求锁，此时会阻塞reader
</span><span class="c1"></span>    <span class="nx">readerWait</span> <span class="kt">int32</span>  <span class="c1">// writer等待完成的reader的数量
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">const</span> <span class="nx">rwmutexMaxReaders</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span> <span class="c1">// 最大的reader数量
</span></code></pre></div><h3 id="基本-2">基本</h3>
<ul>
<li>主要提升Mutex在读多写少的场景下的吞吐量，读时共享锁，写时排他锁，基于Mutex实现</li>
<li>由5个方法构成：
<ul>
<li>Lock/Unlock：写操作时调用的方法。如果锁已经被 reader 或者 writer 持有，那么，Lock 方法会一直阻塞，直到能获取到锁；Unlock 则是配对的释放锁的方法。</li>
<li>RLock/RUnlock：读操作时调用的方法。如果锁已经被 writer 持有的话，RLock 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 RUnlock 是 reader 释放锁的方法。</li>
<li>RLocker：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法</li>
</ul>
</li>
<li>同Mutex，RWMutex的零值是未加锁状态，无需显示地初始化</li>
<li>由于读写锁的存在，可能会有饥饿问题：比如因为读多写少，导致写锁一直加不上，因此go的RWMutex使用的是写锁优先策略，如果已经有一个writer在等待请求锁的话，会阻止新的reader请求读锁，优先保证writer。如果已经有一些reader请求了读锁，则新请求的writer会等待在其之前的reader都释放掉读锁后才请求获取写锁，等待writer解锁后，后续的reader才能继续请求锁。</li>
<li>同Mutex，均为不可重入，使用时应避免复制；要注意reader在加读锁后，不能加写锁，否则会形成相互依赖导致死锁；注意reader是可以重复加读锁的，重复加读锁时，外层reader必须=里层的reader释放锁后自己才能释放锁。</li>
<li>必须先使用RLock / Lock方法才能使用RUnlock / Unlock方法，否则会panic，重复释放锁也会panic。</li>
<li>可以利用RWMutex实现线程安全的map</li>
</ul>
<h3 id="rlock--runlock-方法">RLock / RUnlock 方法</h3>
<ol>
<li>RLock时，对readerCount的值+1，判断是否&lt; 0，如果是，说明此时有writer在竞争锁或已持有锁，则将当前goroutine加入readerSem指向的队列中，进行等待，防止写锁饥饿。</li>
<li>RUnlock时，对readerCount的值-1，判断是否&lt;0，如果是，说明当前有writer在竞争锁，调用rUnlockSlow方法，对readerWait的值-1，判断是否=0，如果是，说明当前goroutine是最后一个要解除读锁的，此时会唤醒要请求写锁的writer。</li>
</ol>
<h3 id="lock方法-1">Lock方法</h3>
<p>RWMutex内部使用Mutex实现写锁互斥，解决多个writer间的竞争</p>
<ol>
<li>调用w的Lock方法加锁，防止其他writer上锁，反转 readerCount的值，使其变成负数（readerCount - rwmutexMaxReaders + rwmutexMaxReaders）告诉reader有writer要请求锁</li>
<li>如果此时readerCount != 0，说明当前有reader持有读锁，需要记录需要等待完成的reader的数量，即readerWait的值（readerWaiter + 第1步算的readerCount的值），并且如果此时readerWait != 0，将当前goroutine加入writerSema指向的队列中，进行等待。直到有goroutine调用RUnlock方法且是最后一个释放锁时，才会被唤醒。</li>
</ol>
<h3 id="unlock方法-1">Unlock方法</h3>
<ol>
<li>反转readerCount的值（readerCount + rwmutexMaxReaders），使其变成reader的数量，唤醒这些reader</li>
<li>调用w的Unlock方法释放当前goroutine的锁，让其他writer可以继续竞争。</li>
</ol>
<h2 id="waitgroup">WaitGroup</h2>
<h3 id="数据结构-3">数据结构</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span> <span class="p">{</span> 
    <span class="c1">// 避免复制，使用vet工具在编译时检测是否被复制
</span><span class="c1"></span>    <span class="nx">noCopy</span> <span class="nx">noCopy</span>
    <span class="c1">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样
</span><span class="c1"></span>    <span class="c1">// 如果地址是64bit对齐，数组前两个元素做state，后一个元素做信号量；如果地址是32bit对齐，数组后两个元素做state，第一个元素做信号量
</span><span class="c1"></span>    <span class="c1">// 高32bit是WaitGroup的计数值，低32bit是waiter的计数,另外32bit是用作信号量
</span><span class="c1"></span>    <span class="nx">state1</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></div><h3 id="基本-3">基本</h3>
<ul>
<li>state的值由32bit的值表示信号量，64bit的值表示计数和waiter的数量组成。因为原子操作只能64bit对齐，而计数值和waiter的数量是一个64bit的值，在64bit的编译器上，一次读取是64bit，刚好可以直接操作，但是如果是32bit的机器，一次只能读32bit，为了保证进行64bit对齐时一定能获取到计数值和waiter的值，在进行64bit的原子操作对齐时，第一次是对齐到了一个空32bit和第一个32bit的值，第二次对齐就能保证获取了。</li>
<li>同RWMutex，WaitGroup的三个方法内还很多data race检查，保证并发时候共享数据的正确性，一旦检查出有问题，会直接panic</li>
<li>一开始设置WaitGroup的计数值必须大于等于0，否则会过不了data race检查，直接panic</li>
<li>Add的值必须=调用调用Done的次数，当Done的次数超过计数值，也会panic</li>
<li>Wait方法的调用一定要晚于Add，否则会导致死锁</li>
<li>WaitGroup可以在计数值为0时可重复使用</li>
<li>noCopy是一个实现了Lock接口的结构体，且不对外暴露，其Lock方法和Unlock方法都是空实现，用于vet工具检查WaitGroup在使用过程中有没有被复制；当我们自定义的结构不想被复制使用时，也可以使用它。</li>
<li>使用时要避免复制</li>
</ul>
<h3 id="add方法">Add方法</h3>
<ol>
<li>原子的将WaitGroup的计数值加到state上，如果当前的计数值 &gt; 0，或者 waiter的数量等于0，直接返回</li>
<li>否则，即代表当前的计数值为0，但waiter的数量不一定为0，此时state的值就是waiter的数量</li>
<li>将state的值设置为0，即waiter的数量设置为0，然后唤醒所有waiter</li>
</ol>
<h3 id="done方法">Done方法</h3>
<ol>
<li>调用Add方法，只是参数为-1，表示计数值 - 1，有一个waiter完成其任务；waiter指的是调用Wait方法的goroutine</li>
</ol>
<h3 id="wait方法">Wait方法</h3>
<ol>
<li>循环内不断检测state的值，当其计数值为0时，说明所有任务已经完成，调用这个方法的goroutine不必继续等待，直接返回，结束该方法</li>
<li>否则，说明此时还有任务没完成，调用该方法的goroutine成为waiter，把waiter的数量 + 1，加入等待队列，阻塞自己</li>
</ol>
<h2 id="cond--condition--waitnotify">Cond = condition + Wait/Notify</h2>
<h3 id="数据结构-4">数据结构</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cond</span> <span class="kd">struct</span> <span class="p">{</span> 
    <span class="nx">noCopy</span> <span class="nx">noCopy</span> <span class="c1">// 使用vet工具在编译时检测是否被复制
</span><span class="c1"></span>    <span class="nx">checker</span> <span class="nx">copyChecker</span> <span class="c1">// 用于运行时被检测是否被复制
</span><span class="c1"></span>    <span class="nx">L</span> <span class="nx">Locker</span> <span class="c1">// 当观察或者修改等待条件的时候需要加锁
</span><span class="c1"></span>    <span class="nx">notify</span> <span class="nx">notifyList</span> <span class="c1">// 等待队列 
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="基本-4">基本</h3>
<ul>
<li>
<p>初始化时，要指定使用的锁，比如Mutex</p>
</li>
<li>
<p>Cond 是等待某个条件满足，这个条件的修改可以被任意多的 goroutine 更新，而且 Cond 的 Wait 不关心也不知道其他 goroutine 的数量，只关心等待条件。</p>
</li>
<li>
<p>Signal方法，类似Java的notify方法，允许调用者唤醒一个等待此Cond的goroutine，如果此时没有waiter，则无事发生；如果此时Cond的等待队列中有多个goroutine，则移除队首的goroutine并唤醒；</p>
<p>使用Signal方法时不强求已调用了加锁方法</p>
</li>
<li>
<p>Broadcast方法，类似Java的notifyAll方法，允许调用者唤醒等待此Cond的所有goroutine，如果此时没有waiter，则无事发生；如果此时Cond的等待队列中有多个goroutine，则清空整个等待队列，全部唤醒；</p>
<p>使用Broadcast方法时不强求已调用了加锁方法</p>
</li>
<li>
<p>Wait方法，类似Java的wait方法，把调用者的goroutine放入Cond的等待队列中并阻塞，直到被Signal或Broadcast方法唤醒</p>
<p>调用Wait方法时必须已调用了加锁方法，否则会panic，因为Wait方法内是<strong>先解锁</strong>，将当前goroutine加入到<strong>等待</strong>队列，然后<strong>解锁</strong>，阻塞休眠当前goroutine，直到被<strong>唤醒</strong>，然后<strong>加锁</strong></p>
<p>调用Wait后一定要检测等待条件是否满足，还需不需要继续等待，在等待的goroutine被唤醒不等于等待条件已满足，可能只是被某个goroutine唤醒而已，被唤醒时，只是得到了一次检测机会。</p>
</li>
</ul>
<h2 id="once">Once</h2>
<h3 id="数据结构-5">数据结构</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">done</span> <span class="kt">uint32</span>
    <span class="nx">m</span> <span class="nx">Mutex</span>
<span class="p">}</span>
</code></pre></div><h3 id="基本-5">基本</h3>
<ul>
<li>sync.Once只有一个Do方法，入参是一个无参数无返回值的函数，当且仅当第一次调用Do方法的时候该函数才会执行，即使之后调用了n次、入参的值不一样都不会被执行</li>
<li>可以将sync.Once与想要只初始化一次的对象封装成一个结构体，提供只初始化一次该值的方法，常用于初始化单例资源、并发访问只初始化一次的共享资源、需要延迟初始化的场景等</li>
<li>Once传入的函数参数，就算在执行时发生panic，Once也会认为已经执行过了，so如果要知道Once里传入的方法是否执行成功，模仿Do函数自己写一个返回参数的入参方法</li>
<li>内部的实现非常简单，就是一个flag + 一个双重校验锁</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 判断flag是否被置为0，即函数是否还没被执行过
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> 
        <span class="nx">o</span><span class="p">.</span><span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> 
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span> 
    <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span> 
    <span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 因为其他最外层的判断+LoadUnit32没有被锁保护，so这里得原子操作
</span><span class="c1"></span>        <span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
        <span class="nf">f</span><span class="p">()</span> 
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="并发安全的map">并发安全的map</h2>
<ul>
<li>
<p>将map与RWMutex封装成一个结构体，使用读写锁封装map的各种操作即可</p>
</li>
<li>
<p>使用RWMutex封装的并发安全的map，因为锁的粒度太大，性能不会太好；通过减少锁的粒度和持有锁的时间，可以提升新能，常见的减少锁的粒度是将锁分片，将锁进行分片，分别控制map中不同的范围的key，类似JDK7中的ConcurrentHashMap的segment锁实现。</p>
</li>
<li>
<p>官方出品的sync.Map，但它只有在部分特殊的场景里才有优势，比如一个只会增长的map，一个key只会被写一次，读很多次；或者 多个goroutine为不相交的键集读、写和重写键值对</p>
<p>sync.Map内部有两个map，一个只读read，一个可写dirty，对只读read的操作(读、更新、删除)不需要加锁，以此减少锁对性能的影响。</p>
<p>如果read中读不到，就会加锁读取dirty里的，同时增加miss的值(miss表示读取穿透的次数)，当miss的值=dirty的长度时，就会将dirty提升为read，然后清空dirty，避免总是从dirty中加锁读取</p>
<p>加锁读取dirty时，还要再检查read，确定read中真的不存在才会操作dirty</p>
<p>dirty提升为read时，只需简单的赋值即可，创建新的dirty时，需要遍历把read中非expunged的值赋给dirty</p>
<p>删除key时，只是对该key打上一个expunged标记，只有在将dirty提升为read时才会清理删除的数据</p>
<p>sync.Map没有len方法，要获取里面有多少个key只能遍历获取</p>
</li>
</ul>
<h2 id="pool">Pool</h2>
<h3 id="数据结构-6">数据结构</h3>
<p>![](<a class="link" href="https://github.com/Nixum/Java-Note/raw/master/picture/go"  target="_blank" rel="noopener"
    >https://github.com/Nixum/Java-Note/raw/master/picture/go</a> syncPool数据结构.png)</p>
<ul>
<li>每次垃圾回收时，Pool会把victim中的对象移除，然后把local的数据给victim，local置为nil，如果此时有Get方法被调用，则会从victim中获取对象。通过这种方式，避免缓存元素被大量回收后再再次使用时新建很多对象</li>
<li>获取重用对象时，先从local中获取，获取不到再从victim中获取</li>
<li>poolLocalInternal用于CPU缓存对齐，避免false sharing</li>
<li>private字段代表一个缓存元素，且只能由相应的一个P存取，因为一个P同时只能执行一个goroutine，所以不会有并发问题</li>
<li>shared字段可以被任意的P访问，但是只有本地的P次啊能pushHead/popHead，其他P可以popTail，相当于只有一个本地P作为生产者，多个P作为消费者，它由一个local-free的队列实现</li>
</ul>
<h3 id="基本-6">基本</h3>
<ul>
<li>sync.Pool用于保存一组可独立访问的临时对象，它池化的对象如果没有被其他对象持有引用，可能会在未来某个时间点被回收掉</li>
<li>sync.Pool是并发安全的，多个gotoutine可以并发调用它存取对象；</li>
<li>不能复制使用</li>
<li>在1.13以前，保证并发安全使用了带锁的队列，1.13后，改成了lock-free的队列实现，避免锁对性能的影响</li>
<li>包含了三个方法：New、Get、Put；Get方法调用时，会从池中移走该元素</li>
<li>当Pool里没有元素可用时，Get方法会返回nil；可以向Pool中Put一个nil的值，Pool会将其忽略</li>
<li>当使用Pool作为buffer池时，要注意buffer如果太大，reset后它就会占很大空间，引起内存泄漏，因此在回收元素时，需要检查大小，如果太大了就直接置为null，丢弃即可</li>
</ul>
<h3 id="get方法">Get方法</h3>
<ol>
<li>将当前goroutine固定在P上，优先从local的private字段取出一个元素，将private置为null</li>
<li>如果取出的元素为null，从当前的local.shared的head中取出一个元素，如果还取不到，调用getSlow函数去其他shared中取</li>
<li>getSlow函数会遍历所有local，从它们的shared的head中弹出一个元素，如果还没有，则对victim中以在同样的方式(先从private里找，找不到再在shared里找)获取一遍</li>
<li>如果还取不到，则调用New函数生成一个，然后返回</li>
</ol>
<p>因为当前的goroutine被固定在了P上，在查找元素时不会被其他P执行</p>
<h3 id="put方法">Put方法</h3>
<ol>
<li>如果Put进来的元素是null，直接返回</li>
<li>固定当前goroutine，如果本地private没有值，直接设置，否则加入到shared中</li>
</ol>
<h2 id="原子操作">原子操作</h2>
<ul>
<li>
<p>依赖atomic包，因为没有泛型，目前该包支持int32、int64、uint32、unit64、uintptr、Pointer的原子操作，比如Add、CompareAndSwap、Swap、Load、Store等（Pointer不支持Add），对于有符号的数值来说，Add一个负数相当于减</p>
</li>
<li>
<p>对于现代多核操作系统来说，由于cache、指令重排、可见性问题，一个核对地址的值的更改，在更新到主内存中前，会先存在多级缓存中，此时，多个核看到该数据可能还没看到更新的数据，还在使用旧数据，而atomic包提供的方法会提供内存屏障的功能，保证赋值数据的完整性和可见性</p>
</li>
<li>
<p>atomic操作的对象是一个地址，不是变量值</p>
</li>
</ul>
<p>用atomic实现的lock-free的队列</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">queue</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;sync/atomic&#34;</span>
  <span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>
<span class="c1">// lock-free的queue
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">LKQueue</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">head</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
  <span class="nx">tail</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
<span class="c1">// 通过链表实现，这个数据结构代表链表中的节点
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">value</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">next</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">NewLKQueue</span><span class="p">()</span> <span class="o">*</span><span class="nx">LKQueue</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">node</span><span class="p">{})</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">LKQueue</span><span class="p">{</span><span class="nx">head</span><span class="p">:</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">tail</span><span class="p">:</span> <span class="nx">n</span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 入队
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">LKQueue</span><span class="p">)</span> <span class="nf">Enqueue</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{</span><span class="nx">value</span><span class="p">:</span> <span class="nx">v</span><span class="p">}</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">tail</span> <span class="o">:=</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span>
    <span class="nx">next</span> <span class="o">:=</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tail</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">tail</span> <span class="o">==</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 尾还是尾
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// 还没有新数据入队
</span><span class="c1"></span>        <span class="k">if</span> <span class="nf">cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tail</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//增加到队尾
</span><span class="c1"></span>          <span class="nf">cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">tail</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="c1">//入队成功，移动尾巴指针
</span><span class="c1"></span>          <span class="k">return</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 已有新数据加到队列后面，需要移动尾指针
</span><span class="c1"></span>        <span class="nf">cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">tail</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 出队，没有元素则返回nil
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">LKQueue</span><span class="p">)</span> <span class="nf">Dequeue</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">head</span> <span class="o">:=</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span>
    <span class="nx">tail</span> <span class="o">:=</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span>
    <span class="nx">next</span> <span class="o">:=</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// head还是那个head
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="nx">tail</span> <span class="p">{</span> <span class="c1">// head和tail一样
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// 说明是空队列
</span><span class="c1"></span>          <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 只是尾指针还没有调整，尝试调整它指向下一个
</span><span class="c1"></span>        <span class="nf">cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">tail</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 读取出队的数据
</span><span class="c1"></span>        <span class="nx">v</span> <span class="o">:=</span> <span class="nx">next</span><span class="p">.</span><span class="nx">value</span>
        <span class="c1">// 既然要出队了，头指针移动到下一个
</span><span class="c1"></span>        <span class="k">if</span> <span class="nf">cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">v</span> <span class="c1">// Dequeue is done.  return
</span><span class="c1"></span>        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 将unsafe.Pointer原子加载转换成node
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">load</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">node</span><span class="p">)(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// 封装CAS,避免直接将*node转换成unsafe.Pointer
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">cas</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="p">(</span><span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span>
    <span class="nx">p</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">old</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">new</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h2 id="weighted--semaphore信号量">Weighted = Semaphore信号量</h2>
<h3 id="数据结构-7">数据结构</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Weighted</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">size</span>    <span class="kt">int64</span>         <span class="c1">// 最大资源数
</span><span class="c1"></span>    <span class="nx">cur</span>     <span class="kt">int64</span>         <span class="c1">// 当前已被使用的资源
</span><span class="c1"></span>    <span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>    <span class="c1">// 互斥锁，对字段的保护
</span><span class="c1"></span>    <span class="nx">waiters</span> <span class="nx">list</span><span class="p">.</span><span class="nx">List</span>     <span class="c1">// 等待队列，通过channel实现通知机制
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="基本-7">基本</h3>
<ul>
<li>
<p>信号量中的PV操作，P：获取资源，如果获取不到，则阻塞，加入到等待队列中；V：释放资源，从等待队列中唤醒一个元素执行P操作</p>
</li>
<li>
<p>二进位信号量，或者说只有一个计数值的信号量，其实相当于go中的Mutex互斥锁</p>
</li>
<li>
<p>初始化时，必须指定初始的信号量</p>
</li>
<li>
<p>只调用Release方法会直接panic；Release方法传入负数，会导致资源被永久持有；因此要保证请求多少资源，就释放多少资源</p>
</li>
<li>
<p>Mutex中使用的sema是一个信号量，只是其实现是在runtime中，并没有对外暴露，在扩展包中，暴露了一个信号量工具Weighted</p>
</li>
<li>
<p>Weighted分为3个方法：Acquire方法，相当于P操作，第一个参数是context，可以使用context实现timeout或cancel机制，终止goroutine；正常获取到资源时，返回null，否则返回ctx.Err，信号量计数值不变。</p>
<p>Release方法，相当于V操作，可以释放n个资源，返回给信号量；</p>
<p>TryAcquire方法，尝试获取n个资源，但不会阻塞，成功时返回true，否则一个也不获取，返回false</p>
</li>
<li>
<p>信号量的实现也可通过buffer为n的channel实现，只是一次只能请求一个资源，而Weighted一次可以请求多个</p>
</li>
</ul>
<h3 id="acquire方法">Acquire方法</h3>
<ol>
<li>加锁，判断可用资源 &gt;= 入参所需的资源数，且没有waiter，说明资源足够，直接cur+上所需资源数，解锁返回</li>
<li>如果所需资源数&gt;最大资源数，说明是不可能任务，解锁，依赖ctx的Done方法返回，否则一直等待</li>
<li>如果资源数不够，将调用者加入等待队列，并创建一个read chan，用于通知唤醒，解锁</li>
<li>等待唤醒有两种条件，一种是通过read chan唤醒，另一种是通过ctx.Done唤醒</li>
</ol>
<h3 id="release方法">Release方法</h3>
<ol>
<li>加锁，当前已使用资源数cur - 入参要释放的资源数，唤醒等待队列中的元素，解锁</li>
<li>唤醒等待队列的元素时，会遍历waiters队列，按照先入先出的方式唤醒调用者，前提是释放的资源数要够队首的元素资源的要求，比如释放100个资源，但是队首元素要求101个资源，那队列中的所有等待者都将继续等待，直到队首元素出队，这样做是为了避免饥饿</li>
</ol>
<h2 id="singleflight">SingleFlight</h2>
<h3 id="结构体">结构体</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 代表一个正在处理的请求，或者已经处理完的请求
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">call</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="c1">// 这个字段代表处理完的值，在waitgroup完成之前只会写一次, waitgroup完成之后就读取这个值
</span><span class="c1"></span>    <span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
    <span class="nx">err</span> <span class="kt">error</span>
  
    <span class="nx">forgotten</span> <span class="kt">bool</span>  <span class="c1">// 指示当call在处理时是否要忘掉这个key
</span><span class="c1"></span>    <span class="nx">dups</span>  <span class="kt">int</span>  <span class="c1">// 相同的key的请求数
</span><span class="c1"></span>    <span class="nx">chans</span> <span class="p">[]</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Result</span>
<span class="p">}</span>
  
<span class="c1">// group代表一个singleflight对象
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>       <span class="c1">// protects m
</span><span class="c1"></span>    <span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">call</span> <span class="c1">// lazily initialized
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="基本-8">基本</h3>
<ul>
<li>
<p>SingleFlight可以合并多个请求为一个请求，再将该请求的结果返回给多个请求，从而达到合并并发请求的目的，减少并发调用的数量。比如有多个相同的读请求查库，那就可以合并成一个请求查库，再把结果响应回这多个请求中；或者是解决缓存击穿问题，降低对下游服务的并发压力</p>
</li>
<li>
<p>底层由Mutex和Map实现，Mutex保证并发读写保护，Map保存同一个key正在处理的请求</p>
</li>
<li>
<p>包含3个方法，Do方法：提供一个key和一个函数，对于同一个key，在同一时间只有一个函数在执行，之后同一个key并发的请求会等待，等到第一个执行的结果就是该key的所有结果，调用完成后，会移除这个key。返回值shared表示结果是否来自多个相同请求。</p>
<p>DoChan方法：类似Do方法，只是返回是一个chan，待入参函数执行完，产生结果后就能在chan中接收这个结果</p>
<p>Forget方法：告诉Group忽略这个key，之后这个key的请求会执行入参函数，而不是等待前一个未完成的入参函数的结果</p>
</li>
</ul>
<h2 id="cyclicbarrier---循环栅栏">CyclicBarrier - 循环栅栏</h2>
<h3 id="数据结构-8">数据结构</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CyclicBarrier</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// 等待所有的参与者到达，如果被ctx.Done()中断，会返回ErrBrokenBarrier
</span><span class="c1"></span>    <span class="nf">Await</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// 重置循环栅栏到初始化状态。如果当前有等待者，那么它们会返回ErrBrokenBarrier
</span><span class="c1"></span>    <span class="nf">Reset</span><span class="p">()</span>
    <span class="c1">// 返回当前等待者的数量
</span><span class="c1"></span>    <span class="nf">GetNumberWaiting</span><span class="p">()</span> <span class="kt">int</span>
    <span class="c1">// 参与者的数量
</span><span class="c1"></span>    <span class="nf">GetParties</span><span class="p">()</span> <span class="kt">int</span>
    <span class="c1">// 循环栅栏是否处于中断状态
</span><span class="c1"></span>    <span class="nf">IsBroken</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div><h3 id="基本-9">基本</h3>
<ul>
<li>类似Java的CyclicBarrier，允许一组goroutine相互等待，到达一个共同的执行点再继续往下执行；同时也可被重复使用。</li>
<li>CyclicBarrier是一个接口，然后有两个初始化的方法，New方法，指定循环栅栏的参与者数量即可初始化；NewWithAction方法，除了指定参与者数量，第二个参数是一个函数，表示在最后一个参与者到达之后，但其他参与者还没放行之前，会调用该函数</li>
<li>每个参与的goroutine都会调用Await方法进行阻塞，当调用Await方法的goroutine的个数=参与者的数量时，Await方法造成的阻塞才会解除</li>
</ul>
<h2 id="errgroup">ErrGroup</h2>
<ul>
<li>
<p>类似WaitGroup，只是功能更丰富，多了与Context集成，可以通过Context监控是否发生cancel；error可以向上传播，把子任务的错误传递给Wait的调用者</p>
</li>
<li>
<p>ErrGroup用于并发处理子任务，将一个大任务拆成几个小任务，通过Go方法并发执行。</p>
</li>
<li>
<p>ErrGroup有三个方法：withContext、Go、Wait，用法与WaitGroup相似，只是不需要设置计数值，且可以通过Wait方法获取子任务返回的错误，但它只会返回第一个出现的错误，如果所有子任务都执行成功，返回null；当发生错误时不会立即返回，而是等到其他任务完成了才会返回。</p>
</li>
<li>
<p>Go方法会创建一个goroutine来执行子任务，如果并发的量太大，会导致创建大量的goroutine，带来goroutine的调度和GC压力，占用更多资源，解决方案可以是使用worker pool或者信号量来控制goroutine的数量或保持重用</p>
</li>
<li>
<p>子任务如果发生panic会导致程序崩溃</p>
</li>
</ul>
<h2 id="检测工具">检测工具</h2>
<ul>
<li>go race detector：主要用于检测多个goroutine对共享变量的访问是否存在协程安全问题。编译器通过探测所有内存的访问，加入代码监视对内存地址的访问，在程序运行时，监控共享变量的非同步访问，出现race时，打印告警信息。比如在运行时加入race参数<code>go run -race main.go</code>，当执行到一些并发操作时，才会检测运行时是否有并发问题</li>
<li>命令<code>go vet xxx.go</code>可以进行死锁检测</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/go%E5%B9%B6%E5%8F%91/">go并发</a>
        
            <a href="/tags/go%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">go内存模型</a>
        
            <a href="/tags/go-channel%E5%8E%9F%E7%90%86/">go channel原理</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            Last updated on May 15, 2021 00:00 UTC
        </span>
    </section></footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/go/">
        
        

        <div class="article-details">
            <h2 class="article-title">go</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 Nixum Blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.6.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">

            <section class="widget archives">
                <form action="/search/" class="search-form widget" >
        <p>
            <label>Search</label>
            <input name="keyword" required placeholder="Type something..." />
        
            <button title="Search">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



            </button>
        </p>
    </form>
            </section>

            <section class="widget archives">
                <h2 class="widget-title section-title">Contents</h2>

                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#证heppen-before的手段">证heppen before的手段</a></li>
  </ol>

  <ol>
    <li><a href="#数据结构">数据结构</a></li>
    <li><a href="#基本">基本</a></li>
    <li><a href="#初始化">初始化</a></li>
    <li><a href="#发送数据">发送数据</a></li>
    <li><a href="#接收数据">接收数据</a></li>
    <li><a href="#关闭">关闭</a></li>
    <li><a href="#应用场景">应用场景</a></li>
  </ol>

  <ol>
    <li><a href="#mutex---互斥锁">Mutex - 互斥锁</a>
      <ol>
        <li><a href="#数据结构-1">数据结构</a></li>
        <li><a href="#基本-1">基本</a></li>
        <li><a href="#lock方法">Lock方法</a></li>
        <li><a href="#unlock方法">Unlock方法</a></li>
        <li><a href="#基于mutex的拓展">基于Mutex的拓展</a></li>
      </ol>
    </li>
    <li><a href="#rwmutex---读写锁">RWMutex - 读写锁</a>
      <ol>
        <li><a href="#数据结构-2">数据结构</a></li>
        <li><a href="#基本-2">基本</a></li>
        <li><a href="#rlock--runlock-方法">RLock / RUnlock 方法</a></li>
        <li><a href="#lock方法-1">Lock方法</a></li>
        <li><a href="#unlock方法-1">Unlock方法</a></li>
      </ol>
    </li>
    <li><a href="#waitgroup">WaitGroup</a>
      <ol>
        <li><a href="#数据结构-3">数据结构</a></li>
        <li><a href="#基本-3">基本</a></li>
        <li><a href="#add方法">Add方法</a></li>
        <li><a href="#done方法">Done方法</a></li>
        <li><a href="#wait方法">Wait方法</a></li>
      </ol>
    </li>
    <li><a href="#cond--condition--waitnotify">Cond = condition + Wait/Notify</a>
      <ol>
        <li><a href="#数据结构-4">数据结构</a></li>
        <li><a href="#基本-4">基本</a></li>
      </ol>
    </li>
    <li><a href="#once">Once</a>
      <ol>
        <li><a href="#数据结构-5">数据结构</a></li>
        <li><a href="#基本-5">基本</a></li>
      </ol>
    </li>
    <li><a href="#并发安全的map">并发安全的map</a></li>
    <li><a href="#pool">Pool</a>
      <ol>
        <li><a href="#数据结构-6">数据结构</a></li>
        <li><a href="#基本-6">基本</a></li>
        <li><a href="#get方法">Get方法</a></li>
        <li><a href="#put方法">Put方法</a></li>
      </ol>
    </li>
    <li><a href="#原子操作">原子操作</a></li>
    <li><a href="#weighted--semaphore信号量">Weighted = Semaphore信号量</a>
      <ol>
        <li><a href="#数据结构-7">数据结构</a></li>
        <li><a href="#基本-7">基本</a></li>
        <li><a href="#acquire方法">Acquire方法</a></li>
        <li><a href="#release方法">Release方法</a></li>
      </ol>
    </li>
    <li><a href="#singleflight">SingleFlight</a>
      <ol>
        <li><a href="#结构体">结构体</a></li>
        <li><a href="#基本-8">基本</a></li>
      </ol>
    </li>
    <li><a href="#cyclicbarrier---循环栅栏">CyclicBarrier - 循环栅栏</a>
      <ol>
        <li><a href="#数据结构-8">数据结构</a></li>
        <li><a href="#基本-9">基本</a></li>
      </ol>
    </li>
    <li><a href="#errgroup">ErrGroup</a></li>
    <li><a href="#检测工具">检测工具</a></li>
  </ol>
</nav>
                </div>
            </section>

            <section class="widget archives">
                <h2 class="widget-title section-title">Other Article Tags</h2>
                <section class="widget tagCloud">
    <div class="tagCloud-tags">
        
            <a href="/tags/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/" class="font_size_3">
                主从架构
            </a>
        
            <a href="/tags/javase/" class="font_size_2">
                JavaSE
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="font_size_2">
                数据库
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%94%81/" class="font_size_2">
                数据库-锁
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/" class="font_size_2">
                数据库事务
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="font_size_2">
                数据库优化
            </a>
        
            <a href="/tags/%E7%B4%A2%E5%BC%95/" class="font_size_2">
                索引
            </a>
        
            <a href="/tags/docker/" class="font_size_1">
                docker
            </a>
        
            <a href="/tags/etcd/" class="font_size_1">
                etcd
            </a>
        
            <a href="/tags/git/" class="font_size_1">
                git
            </a>
        
            <a href="/tags/go/" class="font_size_1">
                go
            </a>
        
            <a href="/tags/go-channel%E5%8E%9F%E7%90%86/" class="font_size_1">
                go channel原理
            </a>
        
            <a href="/tags/go-gc/" class="font_size_1">
                go GC
            </a>
        
            <a href="/tags/go%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="font_size_1">
                go内存模型
            </a>
        
            <a href="/tags/go%E5%8D%8F%E7%A8%8B/" class="font_size_1">
                go协程
            </a>
        
            <a href="/tags/go%E5%B9%B6%E5%8F%91/" class="font_size_1">
                go并发
            </a>
        
            <a href="/tags/go%E9%9B%86%E5%90%88%E7%B1%BB%E5%8E%9F%E7%90%86/" class="font_size_1">
                go集合类原理
            </a>
        
            <a href="/tags/http/" class="font_size_1">
                HTTP
            </a>
        
            <a href="/tags/ioc%E5%92%8Caop/" class="font_size_1">
                IOC和AOP
            </a>
        
            <a href="/tags/istio/" class="font_size_1">
                Istio
            </a>
        
            <a href="/tags/java-bio/" class="font_size_1">
                Java BIO
            </a>
        
            <a href="/tags/java-gc/" class="font_size_1">
                Java GC
            </a>
        
            <a href="/tags/java-nio/" class="font_size_1">
                Java NIO
            </a>
        
            <a href="/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="font_size_1">
                Java内存模型
            </a>
        
            <a href="/tags/java%E5%B9%B6%E5%8F%91/" class="font_size_1">
                Java并发
            </a>
        
            <a href="/tags/java%E9%9B%86%E5%90%88%E7%B1%BB%E5%8E%9F%E7%90%86/" class="font_size_1">
                Java集合类原理
            </a>
        
            <a href="/tags/juc/" class="font_size_1">
                JUC
            </a>
        
            <a href="/tags/jvm/" class="font_size_1">
                JVM
            </a>
        
            <a href="/tags/jwt/" class="font_size_1">
                JWT
            </a>
        
            <a href="/tags/kubernetes/" class="font_size_1">
                Kubernetes
            </a>
        
            <a href="/tags/linux/" class="font_size_1">
                Linux
            </a>
        
            <a href="/tags/mongodb/" class="font_size_1">
                MongoDB
            </a>
        
            <a href="/tags/mysql/" class="font_size_1">
                MySQL
            </a>
        
            <a href="/tags/netty/" class="font_size_1">
                Netty
            </a>
        
            <a href="/tags/orm/" class="font_size_1">
                ORM
            </a>
        
            <a href="/tags/redis/" class="font_size_1">
                Redis
            </a>
        
            <a href="/tags/rpc/" class="font_size_1">
                RPC
            </a>
        
            <a href="/tags/session%E5%92%8Ccookie/" class="font_size_1">
                session和cookie
            </a>
        
            <a href="/tags/socket/" class="font_size_1">
                socket
            </a>
        
            <a href="/tags/spring/" class="font_size_1">
                Spring
            </a>
        
            <a href="/tags/spring-security/" class="font_size_1">
                Spring Security
            </a>
        
            <a href="/tags/springboot/" class="font_size_1">
                SpringBoot
            </a>
        
            <a href="/tags/springmvc/" class="font_size_1">
                SpringMVC
            </a>
        
            <a href="/tags/tcp/" class="font_size_1">
                TCP
            </a>
        
            <a href="/tags/udp/" class="font_size_1">
                UDP
            </a>
        
            <a href="/tags/uml/" class="font_size_1">
                UML
            </a>
        
            <a href="/tags/zookeeper/" class="font_size_1">
                zookeeper
            </a>
        
            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="font_size_1">
                分布式事务
            </a>
        
            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" class="font_size_1">
                分布式理论
            </a>
        
            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/" class="font_size_1">
                分布式相关
            </a>
        
    </div>
</section>
            </section>

        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
